/*
 * generated by Xtext 2.25.0
 */
package event.driven.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import event.driven.sceneDl.RegularAttribute
import event.driven.sceneDl.PositionAttribute
import java.util.Set
import event.driven.sceneDl.Attribute
import event.driven.sceneDl.Element
import event.driven.sceneDl.Feature
import event.driven.sceneDl.StaticEntity
import event.driven.sceneDl.Contain
import event.driven.sceneDl.DynamicEntity
import event.driven.sceneDl.Scene

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class SceneDlGenerator extends AbstractGenerator {

override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val scene = resource.contents.get(0) as Scene
		
		fsa.generateFile(scene.name + '.scene', '''
		«FOR element : scene.elements»
			«element.type» entity «element.name» {
				«FOR attribute : element.allAttributes.reject[it.isTransient] SEPARATOR ', '»
					«attribute.name»: «attribute.type» «attribute.valueProvider»
				«ENDFOR»
				«FOR containement : element.getAllContainment»
									,«containement.name»: «containement.type.name»
				«ENDFOR»
			}
								
		«ENDFOR»		
		'''
		)
		
	}
	
	def dispatch String valueProvider(RegularAttribute attribute){
			return attribute.value.toString.replace("[","").replace("]","")
	}
	
	def dispatch String valueProvider(PositionAttribute attribute){
			var str = "[" + attribute.x + ";" + attribute.y + "]"
			return str
	}
	
	private  def Set<Attribute> getAllAttributes(Element element) {
		val attributes = newHashSet
		attributes += element.attributes
		for (parent : element.isA) {
			attributes += parent.allAttributes
		}
		return attributes
	}
		
	private dispatch def Set<Feature> getAllContainment(StaticEntity entity) {
		val features = newHashSet
		var lanes = 0
		for (element : entity.attributes) {
			if(element.name.contains("lane")){
				var lan = element as RegularAttribute
				lanes = Integer.parseInt(lan.value.get(0));
			}
		}		
		return features
	}
	
	private dispatch def Set<Contain> getAllContainment(DynamicEntity entity) {
		val features = newHashSet
		features += entity.contains
		return features
	}
	
	private dispatch def String getName(Feature feature) {
		return feature.name
	}
	
	private dispatch def String getName(Contain contain) {
		return contain.name
	}
	
	private dispatch def Element getType(Feature feature) {
		return feature.type
	}

	private dispatch def Element getType(Contain contain) {
		return contain.type
	}
}
